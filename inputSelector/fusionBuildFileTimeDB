#!/usr/bin/python
#
"""buildDB - Build the timespan database from orbits data-file and instrument-file-names data-files

Usage:
    buildDB [-ohqv] [--trace=FILENAME] DB_FILE ORBIT_FILE INSTRUMENT_FILES...
    buildDB -h | --help

Arguments:
    DB_FILE     Path the the database
    ORBIT_FILE  Path to the orbit data file
    INSTRUMENT_FILES Paths to a file with a list of all instrument files

Options:
    -h --help                 Show help
    -o                        Overwrite existing database
    -q                        Quiet mode - omit warnings/anomalies to stdout
    -anomalies=<file>         send input anomalies to <file>
    -v                        verbose, print command/args, file, times, etc on inserts
    -trace=<file>             capture trace/debug output to file

"""

from __future__ import print_function
import sqlite3
import gzip
import sys
from datetime import datetime
import logging
from logging import *
import os
from docopt import docopt
import time
from time import mktime, strptime

args = docopt(__doc__)


class Timer:    
    def __enter__(self):
        self.start = time.clock()
        return self

    def __exit__(self, *args):
        self.end = time.clock()
        self.interval = self.end - self.start
        print ('time: {}'.format(self.interval))


def usage():
    print (__doc__)
    return

def nolog(msg, *args, **kwargs):
    return

if args['-q']:
    warn = nolog

def db_optimize(cursor):
    cursor.execute('PRAGMA synchronous = OFF;')
    cursor.execute('PRAGMA journal_mode = OFF;')
    cursor.execute('PRAGMA locking_mode = EXCLUSIVE;')
    cursor.execute('PRAGMA temp_store = MEMORY;')
    cursor.execute('PRAGMA count_changes = OFF;')
    cursor.execute('PRAGMA PAGE_SIZE = 4096;')
    cursor.execute('PRAGMA default_cache_size=1000000; ')
    cursor.execute('PRAGMA cache_size=1000000;')
    cursor.execute('PRAGMA auto_vacuum=0;')
    cursor.execute('PRAGMA mmap_size=2147483648;')
    cursor.execute('PRAGMA compile_options;')
    return cursor

def createDB(dbfile):
    dbconnection = sqlite3.connect(dbfile)
    cursor = dbconnection.cursor()
    cursor = db_optimize(cursor)

    tstrs = {'CREATE TABLE orbits (orbit integer, path integer, stime integer, etime integer)'}
    tstrs.add('CREATE TABLE dirs (id integer primary key autoincrement, dir text unique)')
    for inst in {"modis", "mopitt", "aster", "ceres", "miser"}:
        tstrs.add('CREATE TABLE {} (stime integer, etime integer, \
            directory integer, fname text, FOREIGN KEY(directory) REFERENCES dirs(dir))'.format(inst))
    for query in tstrs:
        cursor = cursor.execute(query)
    return dbconnection, cursor

# global rows and insert strings to collect all the rows
# then do the inserts at once, misr last (see populate orbit calc)
ROWS = {"orbits": [], "MOD": [], "AST": [], "CER": [], "MOP": [], "MIS": [], "dirs": dict()}
INSERTS = {\
    "orbits": 'insert or ignore into orbits (orbit, path, stime, etime) values (?, ?, ?, ?)',\
    "MOD": 'insert or ignore into modis (directory, fname, stime, etime) values(?, ?, ?, ?)',\
    "AST": 'insert or ignore into aster (directory, fname, stime, etime) values(?, ?, ?, ?)',\
    "CER": 'insert or ignore into ceres (directory, fname, stime, etime) values(?, ?, ?, ?)',\
    "MOP": 'insert or ignore into mopitt (directory, fname, stime, etime) values(?, ?, ?, ?)',\
    "MIS": 'insert or ignore into miser (directory, fname, stime, etime) values(?, ?, ?, ?)',\
    "dirs": 'insert or ignore into dirs (dir, id) values(?,?)'\
    }

odict = dict()
def addOrbits(orbitsfile):
    timeFmt = '%Y-%m-%dT%H:%M:%SZ'
    with gzip.open(orbitsfile, 'r') as infile:
        for line in infile:
            line = line.decode("utf-8-sig")
            line = line.strip()
            if line.startswith('#'):
                continue
            orbitnum, pathnum, starttime, endtime = line.split()
            orbitnum = int(orbitnum)
            stime = int(mktime(strptime(starttime, timeFmt)))
            etime = int(mktime(strptime(endtime, timeFmt)))
            ROWS["orbits"].append((orbitnum, pathnum, stime, etime,))
            odict[orbitnum] = (stime, etime, pathnum)
        if args.get('-v', False):
            [debug("found orbit {} path {} start {} end {}".format(*r)) for r in ROWS['orbits']]
    return

def addDir(directory):
    ddict = ROWS['dirs']
    ddict[directory] = ddict.get(directory, len(ddict))
    
def addmod(directory, fname):
    sformat = '%Y%j%H%M'
    eformat = '%Y%j%H%M%S'
    ss = fname.split('.')
    sstr = ss[1][1:]+ss[2]
    estr = ss[4]
    stime = int(mktime(strptime(sstr, sformat)))
    etime = int(mktime(strptime(estr, eformat)))
    directory = ROWS['dirs'][directory]
    ROWS["MOD"].append((directory, fname, stime, etime,))
    return

def addmop(directory, fname):
    sformat = '%Y%m%d'
    ss = fname.split('-')
    stime = int(mktime(strptime(ss[1], sformat)))
    etime = stime + 24*60*60 # TODO CHECK THIS 24 hours?
    directory = ROWS['dirs'][directory]
    ROWS["MOP"].append((directory, fname, stime, etime,))
    return

def addcer(directory, fname):
    timeFmt = '%Y%m%d'
    ss = fname.split('.')
    stime = int(mktime(strptime(ss[-1], timeFmt)))
    etime = 0 # TODO CHECK THIS
    directory = ROWS['dirs'][directory]
    ROWS["CER"].append((directory, fname, stime, etime,))
    return
   
def addast(directory, fname):
    sformat = '003%d%m%Y%H%M%S'
    ss = fname.split('_')
    startstring = ss[2]
    stime = int(mktime(strptime(startstring, sformat)))
    etime = stime + 9*60  # TODO CHECK 9 mins?
    directory = ROWS['dirs'][directory]
    ROWS["AST"].append((directory, fname, stime, etime,))
    return

def addmisr(directory, fname):
    ss = fname.split('_')
    startstring = ss[6]
    orbit = int(startstring[1:])
    directory = ROWS['dirs'][directory]
    if odict.has_key(orbit):
        ROWS["MIS"].append((directory, fname, odict[orbit][0], odict[orbit][1],))
    else:
        warn("addmisr: no data for orbit %d trying to add %s", orbit, directory+"/"+fname)
    return

def addInstrumentFile(instFile):
    debug("addInstrumentFile(%s)", instFile)
    # THe mapping of filename match to DB add routines
    match_list = {"MOD": addmod, "AST": addast, "CER": addcer, "MOP": addmop, "MIS": addmisr}
    last_directory = ''

    with gzip.open(instFile, 'r') as infile:
        count = 0
        timeprev = time.time()
        report_interval = 50000
        for line in infile:
            count += 1
            # report occasionally
            if (count % report_interval) == 0:
                timenow = time.time()
                rate = report_interval/(timenow-timeprev)
                print('{} processed, rate: {}/s'.format(count, int(rate)))
                timeprev = timenow
            line = line.decode("utf-8-sig").strip()
            # skip comments
            if line.startswith('#') or len(line) == 0:
                continue
            if line.startswith('/') and line.endswith(':'):
                # looks like a path
                warn("addInstrumentFile: new directory %s for following files", line)
                last_directory = line
                continue
            try:
                directory, _, fname = line.rpartition('/')
                addFunc = match_list.get(fname[0:3], False)
                if len(directory) == 0:  # use last seen directory
                    directory = last_directory.rstrip(':')
                addDir(directory)
                addFunc(directory, fname)
            except Exception as e:
                debug("file %s: line %d: failed to add line: %s", instFile, count, line)

    return

def main():
    # First the orbits - some instruments need orbit data
    debug("parsing orbits %s", args['ORBIT_FILE'])    
    addOrbits(args['ORBIT_FILE'])

    for ifile in args['INSTRUMENT_FILES']: # also poulates dirs
        debug("parsing instrument file %s", ifile)
        addInstrumentFile(ifile)

    # dirs is currently a dict name->idx, make dirs to list of (idx, dirname) tuples
    drows = [(k,v) for k,v in ROWS['dirs'].iteritems()]
    ROWS['dirs'] = drows
    # make an orbit#->stime, etime dict
    #otimes = [(k,v) for k,v in ROWS['orbits'].iteritems()]

    #[drows.append((dname, didx,)) for didx, dname in ROWS['dirs'].iteritems()]
    # Now populate the DB from the tables, dirs first, MIS last, as it requires orbit calculation
    try:
        if args['-o']:
            os.remove(args['DB_FILE'])
    except:
        None
    connection, cursor = createDB(args['DB_FILE'])
    for table in ["dirs", "orbits", "MOD", "AST", "CER", "MOP", "MIS"]:
        #debug("execute: {}, ex: {}".format(INSERTS[table], ROWS[table][0]))
        if args.get('-v', False):
            [debug("table {0} data {1}".format(table, r)) for r in ROWS[table]]
        cursor.executemany(INSERTS[table], ROWS[table])
        connection.commit()
    cursor.close()
    return

if __name__ == '__main__':
    if args.get('-v', False):
        print(' '.join(sys.argv))
    logLevel = logging.NOTSET
    if 'LOGLEVEL' in os.environ:
        logLevel = getattr(logging, os.environ['LOGLEVEL'])
     
    tracefile =  args.get('--trace', False)
    if tracefile:
        logoutput = open(tracefile, 'wa')
    else:
        logoutput = sys.stdout
    
    logging.basicConfig(level=logLevel, stream=logoutput, 
	format=sys.argv[0].split('/')[-1]+': %(message)s')
    main()
    sys.exit(0)
