    #!/usr/bin/python
#
"""buildDB - Build the timespan database from orbits data-file and instrument-file-names data-files

Usage:
    buildDB [-oh] DB_FILE ORBIT_FILE INSTRUMENT_FILE
    buildDB -h | --help

Arguments:
    DB_FILE     Path the the database
    ORBIT_FILE  Path to the orbit data file
    INSTRUMENT_FILE Path to a file with a list of all instrument files

Options:
    -h --help   Show help
    -o  Overwrite existing database

"""

from __future__ import print_function
import sqlite3
import gzip
import sys
from datetime import datetime
import logging
from logging import *
import os
from docopt import docopt
import time
from time import mktime, strptime

def usage():
    print (__doc__)
    return

def createDB(dbfile):
    dbconnection = sqlite3.connect(dbfile)
    cursor = dbconnection.cursor()
    tstrs = {'CREATE TABLE orbits (stime integer PRIMARY KEY, etime integer, orbit integer)'}
    for inst in {"modis", "moppit", "aster", "ceres"}:
        tstrs.add('CREATE TABLE {} (stime integer PRIMARY KEY, etime integer, fname text)'.format(inst))
    for table in tstrs:
        cursor = cursor.execute(table)
    return cursor

def addOrbits(cursor, orbitsfile):
    istr = 'INSERT OR IGNORE INTO orbits (stime, etime, orbit) VALUES ({},{},{})'
    timeFmt = '%Y-%m-%dT%H:%M:%SZ'
    with gzip.open(orbitsfile, 'r') as infile:
        for line in infile:
            line = line.decode("utf-8-sig")
            orbitnum, starttime, endtime = line.split()
            stime = time.mktime(datetime.strptime(starttime, timeFmt).timetuple())
            etime = time.mktime(datetime.strptime(endtime, timeFmt).timetuple())
            cursor.execute(istr.format(stime, etime, orbitnum))
    return cursor

def addmod(cursor, directory, fname):
    istr = 'INSERT OR IGNORE INTO modis (stime, etime, fname) VALUES ({},{},"{}")'
    sformat = '%Y%j%H%M'
    eformat = '%Y%j%H%M%S'
    ss = fname.split('.')
    sstr = ss[1][1:]+ss[2]
    estr = ss[4]
    stime = int(mktime(strptime(sstr, sformat)))
    etime = int(mktime(strptime(estr, eformat)))
    debug("add modus %d %d %s", stime, etime, directory+'/'+fname)
    qs = istr.format(stime, etime, directory+'/'+fname)
    cursor.execute(qs)
    return cursor

def addast(cursor, directory, fname):
    istr = 'INSERT OR IGNORE INTO aster (stime, etime, "fname") VALUES ({}, {},"{}")'
    sformat = '003%d%m%Y%H%M%S'
    ss = fname.split('_')
    startstring = ss[2]
    stime = int(mktime(strptime(startstring, sformat)))
    etime = stime+9
    debug("add aster %d %d %s", stime, etime, directory+'/'+fname)
    cursor.execute(istr.format(stime, etime, directory+'/'+fname))
    return cursor

def addInstrumentFile(cursor, instFile):
    debug("addInstrumentFile(%s)", instFile)
    match_list = {"MOD": addmod, "AST": addast}

    with gzip.open(instFile, 'r') as infile:
        for line in infile:
            line = line.decode("utf-8-sig").rstrip('\n')
            directory, _, fname = line.rpartition('/')

            # Cycle through the matches from the last position, warn if not found
            addFunc = match_list.get(fname[0:3])
            if addFunc is None:
                warn("addInstrumentFile: no match for line %s", line)
            else:
                addFunc(cursor, directory, fname)
    return cursor



'''def addInstruments(cursor, instfile):
    istr = 'INSERT OR IGNORE INTO {} (stime, etime, filename) VALUES ({},{},{})'
    # get line
    with gzip.open(orbitsfile, 'r') as infile:
        for line in infile:
            line = line.decode("utf-8-sig")
            inst = which_inst(line)
            stime, etime, fname = maketimes['inst'](line)
            cursor = cursor.execute(istr.format(inst, stime, etime, line))

    return cursor'''

def main():
    args = docopt(__doc__)
    if args['-o']:
        os.remove(args['DB_FILE'])
    cursor = createDB(args['DB_FILE'])
    cursor = addOrbits(cursor, args['ORBIT_FILE'])
    addInstrumentFile(cursor, args['INSTRUMENT_FILE'])
    print ('end')
    return


if __name__ == '__main__':
    logLevel = logging.NOTSET
    if 'LOGLEVEL' in os.environ:
        logLevel = getattr(logging, os.environ['LOGLEVEL'])
    logging.basicConfig(level=logLevel, stream=sys.stdout, 
	format=sys.argv[0].split('/')[-1]+': %(message)s')
    main()
    sys.exit(0)





